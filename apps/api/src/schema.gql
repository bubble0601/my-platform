# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type UserCountAggregate {
  id: Int!
  createdAt: Int!
  updatedAt: Int!
  name: Int!
  _all: Int!
}

type UserAvgAggregate {
  id: Float
}

type UserSumAggregate {
  id: String
}

type UserMinAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type UserMaxAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

type UserCount {
  songs: Int!
  albums: Int!
  artists: Int!
  playlists: Int!
}

type ArtistCount {
  albums: Int!
  songs: Int!
}

type Artist {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  userId: String
  user: User
  name: String!
  ruby: String
  albums: [Album!]
  songs: [Song!]
  _count: ArtistCount!
}

type AlbumCount {
  songs: Int!
}

type Album {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  userId: String!
  user: User!
  title: String!
  artistId: String!
  artist: Artist!
  year: Int
  trackCount: Int
  discCount: Int
  songs: [Song!]
  _count: AlbumCount!
}

type PlaylistCount {
  songs: Int!
}

type Playlist {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  userId: String!
  user: User!
  name: String!
  songs: [PlaylistsSongs!]
  _count: PlaylistCount!
}

type PlaylistsSongs {
  playlistId: String!
  songId: String!
  weight: Int!
  playlist: Playlist!
  song: Song!
}

type SongCount {
  playlists: Int!
}

type Song {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  userId: String!
  user: User!
  enabled: Boolean!
  title: String!
  filename: String!
  digest: String!
  albumId: String
  album: Album
  artistName: String
  artistId: String
  artist: Artist
  year: Int
  trackNum: Int
  discNum: Int
  hasCoverArt: Boolean!
  hasLyrics: Boolean!
  length: Int!
  rating: Int!
  playedCount: Int!
  syncedPlayedCount: Int!
  playedAt: DateTime
  playlists: [PlaylistsSongs!]
  _count: SongCount!
}

type User {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
  name: String!
  songs: [Song!]
  albums: [Album!]
  artists: [Artist!]
  playlists: [Playlist!]
  _count: UserCount!
}

type LoginResponse {
  user: User!
}

type SongCountAggregate {
  id: Int!
  createdAt: Int!
  updatedAt: Int!
  userId: Int!
  enabled: Int!
  title: Int!
  filename: Int!
  digest: Int!
  albumId: Int!
  artistName: Int!
  artistId: Int!
  year: Int!
  trackNum: Int!
  discNum: Int!
  hasCoverArt: Int!
  hasLyrics: Int!
  length: Int!
  rating: Int!
  playedCount: Int!
  syncedPlayedCount: Int!
  playedAt: Int!
  _all: Int!
}

type SongAvgAggregate {
  id: Float
  userId: Float
  albumId: Float
  artistId: Float
  year: Float
  trackNum: Float
  discNum: Float
  length: Float
  rating: Float
  playedCount: Float
  syncedPlayedCount: Float
}

type SongSumAggregate {
  id: String
  userId: String
  albumId: String
  artistId: String
  year: Int
  trackNum: Int
  discNum: Int
  length: Int
  rating: Int
  playedCount: Int
  syncedPlayedCount: Int
}

type SongMinAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  userId: String
  enabled: Boolean
  title: String
  filename: String
  digest: String
  albumId: String
  artistName: String
  artistId: String
  year: Int
  trackNum: Int
  discNum: Int
  hasCoverArt: Boolean
  hasLyrics: Boolean
  length: Int
  rating: Int
  playedCount: Int
  syncedPlayedCount: Int
  playedAt: DateTime
}

type SongMaxAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  userId: String
  enabled: Boolean
  title: String
  filename: String
  digest: String
  albumId: String
  artistName: String
  artistId: String
  year: Int
  trackNum: Int
  discNum: Int
  hasCoverArt: Boolean
  hasLyrics: Boolean
  length: Int
  rating: Int
  playedCount: Int
  syncedPlayedCount: Int
  playedAt: DateTime
}

type Query {
  songs: [Song!]!
}

type Mutation {
  login(username: String!, password: String!): LoginResponse!
}